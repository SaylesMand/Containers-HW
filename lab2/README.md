## Архитектура
Проект состоит из трёх сервисов:

### 1. **postgres** - База данных
- **Образ:** `postgres:18-alpine`
- **Назначение:** Хранение метаданных Airflow
- **Порт:** `5432` (доступен снаружи)
- **Особенности:**
  - Настроен healthcheck для проверки готовности БД
  - Данные сохраняются в named volume `postgres_data`
  - Все параметры подключения загружаются из `.env`

### 2. **airflow-init** - Инициализация (init-контейнер)
- **Образ:** `airflow-custom:latest` (собирается из локального Dockerfile)
- **Назначение:** Одноразовая инициализация базы данных Airflow
- **Команда:** `airflow db migrate`
- **Особенности:**
  - Автоматически собирается из `Dockerfile`
  - Запускается только после успешного healthcheck PostgreSQL
  - Выполняется один раз (`restart: "no"`)
  - После завершения контейнер останавливается

### 3. **airflow** - Основное приложение
- **Образ:** `airflow-custom:latest` (использует уже собранный образ)
- **Назначение:** Запуск веб-интерфейса и scheduler Airflow
- **Порт:** `8080` (веб-интерфейс)
- **Команда:** `airflow standalone`
- **Особенности:**
  - Запускается только после успешного завершения `airflow-init`
  - Работает постоянно (`restart: always`)
  - Монтирует папки `dags/` и `plugins/` для разработки
  - Данные хранятся в volume `airflow_data`

## Volumes

- **postgres_data** - Хранит данные PostgreSQL
- **airflow_data** - Хранит данные Airflow (логи, конфигурация)
- **./dags** - Bind mount для DAG файлов (разработка)
- **./plugins** - Bind mount для плагинов (разработка)

## Network

Все сервисы подключены к единой сети `airflow-net` (bridge driver), что обеспечивает:
- Изоляцию от других Docker контейнеров
- Взаимодействие между сервисами по именам контейнеров

## Запуск проекта

```bash

# 1. Собрать и запустить все сервисы
docker-compose up -d --build

# 2. Проверить логи
docker-compose logs -f

# 3. Получить пароль администратора
docker exec airflow cat /opt/airflow/simple_auth_manager_passwords.json.generated

# 4. Открыть веб-интерфейс
# http://localhost:8080
```

## Ответы на вопросы

### 1. Можно ли ограничивать ресурсы (например, память или CPU) для сервисов в `docker-compose.yml`? Если нет, то почему, если да, то как?

**Ответ:** Да для сервисов в `docker-compose.yml` можно прописать ограничения по различным ресурсам.  
Пример:
```bash
services:
  web:
    image: nginx:alpine
    ports:
      - "8080:80"

    deploy:
      resources:
        limits:
          cpus: "0.5"   # предел по CPU
          memory: 512M   # предел по RAM
        reservations:
          cpus: "0.25"   # гарантия по CPU
          memory: 256M   # гарантия по RAM
```
Различия `limits` и `reservations`:
- `limits` - жесткие рамки для контейнера, выше этого значения контейнер не должен подниматься.
- `reservations` - гарантированные ресурсы, они учитываются при планировании, чтобы не назначить на узел больше задач, чем он “вытянет” по ресурсам.

### 2. Как можно запустить только определенный сервис из `docker-compose.yml`, не запуская остальные?

**Ответ:** Запускать можно конкретные сервисы по имени сервиса, не поднимая все остальное. В результате `compose` создаст сесть, поднимет указанные сервисы и по умолчанию поднимет их зависимости `depends_on`.   
- Запуск конкретного сервиса:
  ```bash
  docker compose up -d postgres
  ```
- Запуск конкретного сервиса без зависимостей:
  ```bash
  docker compose up -d --no-deps postgres 
  ```
Так же может использоваться инструкция `run`, которая создаёт одноразовый контейнер, в котором:
- Может быть переопределена команда:
  ```bash
  docker compose run --rm postgres bash
  ```
- По умолчанию не пробрасываются указанные в `.yml` порты. Для их проброса используется `--service-ports`

Данные инструкции используются для разных целей:
- `docker compose up` - запуск постоянно работающего сервиса.
- `docker compose run` - нужно однократно выполнить команду на базе настроек сервиса (migrate, collectstatic, консоль и т.п.)